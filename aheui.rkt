#lang racket/base

(require racket/list)

(define filename "snippets/fibonacci/fibo.puzzlet.aheui")

(define (read-next-line-iter file)
	   (let ((line (read-line file)))
	     (if (eof-object? line) '()
	       (cons line (read-next-line-iter file))
               )))

(define (get-char-value ch)
  (char->integer ch))

(define chosungs #("ㄱ" "ㄲ" "ㄴ" "ㄷ" "ㄸ" "ㄹ" "ㅁ" "ㅂ" "ㅃ" "ㅅ" "ㅆ" "ㅇ" "ㅈ" "ㅉ" "ㅊ" "ㅋ" "ㅌ" "ㅍ" "ㅎ"))
(define joongsungs #("ㅏ" "ㅐ" "ㅑ" "ㅒ" "ㅓ" "ㅔ" "ㅕ" "ㅖ" "ㅗ" "ㅘ" "ㅛ" "ㅙ" "ㅚ" "ㅜ" "ㅝ" "ㅞ" "ㅟ" "ㅠ" "ㅡ" "ㅢ" "ㅣ"))
(define jongsungs #(" " "ㄱ" "ㄲ" "ㄳ" "ㄴ" "ㄵ" "ㄶ" "ㄷ" "ㄹ" "ㄺ" "ㄻ" "ㄼ" "ㄽ" "ㄾ" "ㄿ" "ㅀ" "ㅁ" "ㅂ" "ㅄ" "ㅅ" "ㅆ" "ㅇ" "ㅈ" "ㅊ" "ㅋ" "ㅌ" "ㅍ" "ㅎ"))
(define (associate-index i)
  (if (= i (vector-length jongsungs)) '()
      (cons (cons (vector-ref jongsungs i) i) (associate-index (+ i 1)))))
(define jongsung-index (make-hash (associate-index 0)))
(define lines (make-hash (list  (cons " " 0) (cons "ㄱ" 2) (cons "ㄴ" 2) (cons "ㄷ" 3) (cons "ㄹ" 5) (cons "ㅁ" 4) (cons "ㅂ" 4) (cons "ㅅ" 2) (cons "ㅈ" 3) (cons "ㅊ" 4) (cons "ㅋ" 3) (cons "ㅌ" 4) (cons "ㅍ" 4)
                                     (cons "ㄲ" 4) (cons "ㄳ" 4) (cons "ㄵ" 5) (cons "ㄶ" 5) (cons "ㄺ" 7) (cons "ㄻ" 9) (cons "ㄼ" 9) (cons "ㄽ" 7) (cons "ㄾ" 9) (cons "ㄿ" 9) (cons "ㅀ" 8)
                                     (cons "ㅄ" 6) (cons "ㅆ" 4))))

(define (char-not-in-boundary ch)
  (define ch-value (get-char-value ch))
  (if (and (>= ch-value 44032) (<= ch-value 55203)) #f
      #t))

(define (extract-char ch)
;  (newline)
;  (display "ch: ")
;  (display ch)
;  (newline)
  (define ch-value (get-char-value ch))
  (vector
   (vector-ref chosungs (quotient (- ch-value 44032) (* (vector-length joongsungs) (vector-length jongsungs))))
   (vector-ref joongsungs (quotient (remainder (- ch-value 44032) (* (vector-length joongsungs) (vector-length jongsungs))) (vector-length jongsungs)))
   (vector-ref jongsungs (remainder (- ch-value 44032) (vector-length jongsungs)))))
                     
(define storage (make-vector 28))
(vector-fill! storage '())
(define extracted 0)
(define cmd0 0)
(define cmd1 0)
(define cmd2 0)
(define cur-storage 0)
(define new-storage-no 0)
(define decision 1)
(define temp-value 0)
(define temp-value2 0)
(define temp-storage1 0)
(define temp-storage2 0)
(define cmds (list->vector (call-with-input-file filename read-next-line-iter)))

(define (run-aheui pos-x pos-y prev-x prev-y direction storage-no)
  ;define variables that are to be used in this function
  (unless (>= pos-y 0) (set! pos-y (+ (vector-length cmds) pos-y)))
  (unless (< pos-y (vector-length cmds)) (set! pos-y (- pos-y (vector-length cmds))))
  (unless (>= pos-x 0) (set! pos-x (+ (string-length (vector-ref cmds pos-y)) pos-x)))
  (unless (< pos-x (string-length (vector-ref cmds pos-y))) (set! pos-x (- pos-x (string-length (vector-ref cmds pos-y)))))
  
  (define current-char (string-ref (vector-ref cmds pos-y) pos-x))
  (if (char-not-in-boundary current-char)
      ;handle characters out of boundary (not a hangul character)
       (if (= (remainder direction 2) 1) (run-aheui (+ pos-x direction) pos-y pos-x pos-y direction storage-no)
	     (run-aheui prev-x prev-y pos-x (+ pos-y (/ direction 2)) direction storage-no))
       (begin 
       (set! extracted (extract-char current-char))
       (set! cmd0 (vector-ref extracted 0))
       (set! cmd1 (vector-ref extracted 1))
       (set! cmd2 (vector-ref extracted 2))
       (set! cur-storage (vector-ref storage storage-no))
       (set! new-storage-no storage-no)
       (set! decision 1)
       
       ;for debugging
;       (newline)
;       (display (string-ref (vector-ref cmds pos-y) pos-x))
;       (display " x: ")
;       (display pos-x)
;       (display " y: ")
;       (display pos-y)
;       (display " storage-no: ")
;       (display storage-no)
;       (newline)
;       (display "storage: ")
;       (display storage)
;       (newline)
       
       (begin
	(cond ((equal? cmd0 "ㅇ") (void))
	      ;exit with error code?
	      ((equal? cmd0 "ㅎ") (if (= (length cur-storage) 0) (exit 0)
				     (exit (car cur-storage))))
	      ((equal? cmd0 "ㄷ") (vector-set! storage storage-no (cons (+ (cadr cur-storage) (car cur-storage)) (cddr cur-storage))))
	      ((equal? cmd0 "ㄸ") (vector-set! storage storage-no (cons (* (cadr cur-storage) (car cur-storage)) (cddr cur-storage))))
	      ((equal? cmd0 "ㅌ") (vector-set! storage storage-no (cons (- (cadr cur-storage) (car cur-storage)) (cddr cur-storage))))
	      ((equal? cmd0 "ㄴ") (vector-set! storage storage-no (cons (/ (cadr cur-storage) (car cur-storage)) (cddr cur-storage))))
	      ((equal? cmd0 "ㄹ") (vector-set! storage storage-no (cons (remainder (cadr cur-storage) (car cur-storage)) (cddr cur-storage))))
	      ((equal? cmd0 "ㅁ")
	       (define to-display
		 (cond ((= storage-no 21) (last cur-storage))
		       (else (car cur-storage))))
	       (begin 
		 (cond ((equal? cmd2 "ㅇ") (display to-display))
		       ((equal? cmd2 "ㅎ") (display (integer->char to-display))))
		 (cond ((= storage-no 21) (vector-set! storage storage-no (drop-right cur-storage 1)))
		       (else (vector-set! storage storage-no (cdr cur-storage))))))
	      ((equal? cmd0 "ㅂ") (cond ((equal? cmd2 "ㅎ") (vector-set! storage storage-no (cons (get-char-value (read-char (current-input-port))) cur-storage)))
					(else (vector-set! storage storage-no (cons (hash-ref lines cmd2) cur-storage)))))
	      ((equal? cmd0 "ㅃ") (cond ((= storage-no 21) (vector-set! storage storage-no (reverse (cons (last cur-storage) (reverse cur-storage)))))
					(else (vector-set! storage storage-no (cons (car cur-storage) cur-storage)))))
	      ((equal? cmd0 "ㅍ") (vector-set! storage storage-no (cons (cadr cur-storage) (cons (car cur-storage) (cddr cur-storage)))))
	      ((equal? cmd0 "ㅅ") (set! new-storage-no (hash-ref jongsung-index cmd2)) (void))
	      ;what if the storage is empty?
	      ((equal? cmd0 "ㅆ") (unless (= (length cur-storage) 0)
				   (cond ((= storage-no 21) (set! temp-value (last cur-storage)))
					 (else (set! temp-value (car cur-storage))))
				   (cond ((= storage-no 21) (vector-set! storage storage-no (drop-right cur-storage 1)))
					 (else (vector-set! storage storage-no (cdr cur-storage))))
				   (set! cur-storage (vector-ref storage storage-no))
				   (vector-set! storage (hash-ref jongsung-index cmd2) (cons temp-value (vector-ref storage (hash-ref jongsung-index cmd2))))))
	      ((equal? cmd0 "ㅈ") (unless (= (length cur-storage) 0)
				   (cond ((= storage-no 21) (if (>= (car (cdr (reverse cur-storage))) (last cur-storage)) (set! temp-value 1)
                                                                (set! temp-value 0)))
					 (else (if (>= (car (cdr cur-storage)) (car cur-storage)) (set! temp-value 1)
                                                   (set! temp-value 0))))
				   (cond ((= storage-no 21) (vector-set! storage storage-no (drop-right cur-storage 2)))
					 (else (vector-set! storage storage-no (drop cur-storage 2))))
                              (set! cur-storage (vector-ref storage storage-no))
                              (vector-set! storage storage-no (cons temp-value cur-storage))))
	      ((equal? cmd0 "ㅊ") (unless (= (length cur-storage) 0)
				   (cond ((= storage-no 21) (set! temp-value (last cur-storage)))
					 (else (set! temp-value (car cur-storage))))
				   (cond ((= storage-no 21) (vector-set! storage storage-no (drop-right cur-storage 1)))
					 (else (vector-set! storage storage-no (cdr cur-storage))))
                              (set! cur-storage (vector-ref storage storage-no))
                              (if (= temp-value 0) (set! decision -1)
                                  (set! decision 1)))))
	
	
	(cond ((equal? cmd1 "ㅏ") (run-aheui (+ pos-x (* 1 decision)) pos-y pos-x pos-y (* 1 decision) new-storage-no))
	      ((equal? cmd1 "ㅓ") (run-aheui (- pos-x (* 1 decision)) pos-y pos-x pos-y (* -1 decision) new-storage-no))
	      ((equal? cmd1 "ㅗ") (run-aheui pos-x (- pos-y (* 1 decision)) pos-x pos-y (* -2 decision) new-storage-no))
	      ((equal? cmd1 "ㅜ") (run-aheui pos-x (+ pos-y (* 1 decision)) pos-x pos-y (* 2 decision) new-storage-no))
	      ((equal? cmd1 "ㅑ") (run-aheui (+ pos-x (* 2 decision)) pos-y pos-x pos-y (* 1 decision) new-storage-no))
	      ((equal? cmd1 "ㅕ") (run-aheui (- pos-x (* 2 decision)) pos-y pos-x pos-y (* -1 decision) new-storage-no))
	      ((equal? cmd1 "ㅛ") (run-aheui pos-x (- pos-y (* 2 decision)) pos-x pos-y (* -2 decision) new-storage-no))
	      ((equal? cmd1 "ㅠ") (run-aheui pos-x (+ pos-y (* 2 decision)) pos-x pos-y (* 2 decision) new-storage-no))
	      ;decision with ㅊ not implemented below here
	      ((equal? cmd1 "ㅡ")
	       (if (= (remainder direction 2) 1) (run-aheui (+ pos-x direction) pos-y pos-x pos-y direction new-storage-no)
		   (run-aheui prev-x prev-y pos-x pos-y (* direction -1) new-storage-no)))
	      ((equal? cmd1 "ㅣ")
	       (if (= (remainder direction 2) 0) (run-aheui pos-x (+ pos-y (/ direction 2)) pos-x pos-y direction new-storage-no)
		   (run-aheui prev-x prev-y pos-x pos-y (* direction -1) new-storage-no)))
	      ((equal? cmd1 "ㅢ") (run-aheui prev-x prev-y pos-x pos-y (* direction -1) new-storage-no))
	      (else (run-aheui prev-x prev-y pos-x pos-y direction new-storage-no)))))))

(define main (run-aheui 0 0 0 0 1 0))
(main)
